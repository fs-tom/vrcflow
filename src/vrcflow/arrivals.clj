;;We need a consistent way to formalize arrivals and entity batches, which may
;;be pre-determined (ala an arrivals file or sequence) or
;;stochastically-generated (via variable interarrival and batch-size fns.)
(ns vrcflow.arrivals
  (:require [spork.entitysystem.store :as store]
            [vrcflow.services :as services]))

;;What's a batch? Batches basically describe the arrival of one or more entities
;;into the system at a point in time. At a minimum, we want to know: t - when
;;the batch arrives pending - what's in the batch behavior - the behavior the
;;batch should follow?

;;The original implementation assumed a batch would be defined as a map
;;providing parameters for a stochastically-generated batch.

;;default batching function assumes current-time and builds a batch
;;stochastically based on random interarrival time and random batch-size (if
;;specified). next-batch should take 2 arity, t and ctx, to allow other batch
;;functions to access the context, say to compute deferred batches
;;(pre-scheduled arrivals).

;;this is the prototypical stochastic batch function for generating
;;randomly-arriving entities of variable size. The original implementation
;;focused on variable-sized and variable-timed batches as a function of
;;interarrival-times and random batch-sizes... generate an update for itself the
;;next time... next-batch now accepts a size

;;Primitive Batches
;;=================
;;Revisiting the notion of arrivals and batchin in our simulation....
;;A batch is a representation of one or more entities, placed in simulation
;;time.  It's meant to serve as a placeholder for entities arriving into
;;the system at a later date.

;;Primitive batches consist of nothing but a time and the entities
;;sleighted to arrive.

;;{:t :entities}

;;Arrivals Means Schedule of Entities
;;===================================
;;An arrivals schedule provides a sequence of batches.
;;So, if we read from a file, a bunch of individual entities that
;;are supposed to spawn into the system with a t field, then
;;we can create said schedule in multiple ways, all of them ending
;;with a large sequence of entities ordered by arrival time.

;;Random Batch => higher order fn makes primitive batch
;;=========================================================
;;What if we don't want to reify our entire entity model in the
;;arrivals file.  What if some elements (particularly arrival time)
;;are best left to be generated at runtime?

;;A random batch provides some specification of how to generate
;;a primitive batch at runtime.  The default mechanism is to
;;specify batch-size and other generic characteristics, then
;;derive an entity batch from there (let the sim decide how
;;to fill in the details about what entities are).

;;The problem I created was complecting the random-batch with
;;arrivals generation.  That is, we generate the next-batch
;;from the current batch perpetually.

;;Random Arrivals => fn that computes an arrivals schedule from seed
;;==================================================================
;;To decomplect from our scheduling of entities, we'll have
;;a static schedule and a dynamic schedule.
;;All of these contribute to arrivals, but dynamic schedules
;;are associated with some seed (likely a random batch).

;;Generalizing random and static schedules into a coherent
;;arrivals stream.
;;===============

;;So the trick is to handle both dynamic and static arrivals
;;in a unified fashion.  If I have an arrivals entity, it will
;;have a :pending component.  :pending could be one or more
;;batches.  We need to extract arrivals from pending....
;;I'd like to view pending as a source of one or more arrival
;;streams.  Typically, when we create an arrival batch, we'll
;;have queud an update for the :arrival entity, so we
;;should only be checking when we actually know we have
;;a batch arriving a-priori.

;;From the perspective of handling an arrival, we need to know
;;the consequences of the arrival:
;;  a: which entities arrived in the batch?
;;  b: will there be more batches after this?

;;We should separate the questions into two systems:
;;  a - handling current arrival batches.
;;  b - computing next arrival batches.

;;In the simple-case of primitive entities:
;;  a: the entities associated with :entities key
;;  b: Only if there are pending arrivals for this schedule.
;; (how do we know what the batch schedule is?)
;;  - We should formalize entities into batches.
;;    Create a :schedule to identify which source
;;    produced said entity, and a :batch-id to indicate
;;    the unique batch it came from?

;;In the case of random-entities:
;;  a - The entities generated by batch->entities (from the ctx)
;;  b - If the function (next-batch ...) produces
;;      a new batch.

;;Synthesis: Arrivals via schedules via static and random batches
;;===============================================================
;;So, we discover it may be useful to formalize schedules as entities.
;;We then have the arrivals entity consult known schedules to answer
;;questions a, b.  This generates a sequence of entities to spawn,
;;handled by the normal arrivals process, updated schedules, and
;;updates for the arrivals entity.  If any child schedule has
;;an update, the arrivals entity has an update.

;;This way, we formalize our arrivals system to operate on one or more
;;child entity batch schedules.

;;Entity batch schedules define an abstract stream of entity batches, and
;;provide operations to compute the current batch, as well as the next batch.

;;Static schedules read from an underlying sequence of primitive batches to
;;provide a stream of entity batches over time.

;;Dynamic schedules generate a stream of entity batches over time based on some
;;initial seed, and a transition function.

;;Both static and dynamic schedules reify down to an interleaved sequence of
;;entity orders by time. This is the entity schedule.

;;Basic protocols
;;===============
#_(defprotocol IPrimitiveBatchSchedule
  (next-batch    [schd])
  (current-batch [schd]))

;;say we have static entities from an arrivals file,
;;or some other source.
#_(def ents
    [{:t 1 :entities [{:name :bilbo
                       :age 180}
                      {:name :sam
                       :age 182}
                      {:name :grimlock
                       :age  :me-grimlock-me-no-care}]}
     {:t 50 :entities [{:name :foxy
                        :age 2}
                       {:name :beowulf
                        :age 2}
                       {:name :hearty
                        :age  :3}]}])

;;This conveys two batches of 3 entities a-piece.
;;We'd like to load these into an arrivals schedule.

;;The simplest implementation is to create an entity
#_(def the-schedule
    {:name    :some-arrival-schedule
     :pending ents
     :tstart (first (map :t ents))
     })

;;if we have an entity for :arrival, we can register the-schedule
;;as a schedule...

#_(def arrival-entity
    {:name :arrival
     :schedules {:some-arrival-schedule the-schedule}})

;;Now when we process arrivals, we break up the op into two phases...
;;old...
#_(defn process-arrivals
    "The arrivals system processes batches of entities and schedules more
   arrival updates. batch->entities should be a function that maps a batch, {:t
   long :n long} -> [entity*]"
    ([batch->entities ctx]
     (if-let [arrivals? (seq (sim/get-updates :arrival
                                 (sim/current-time ctx) ctx))]
       (let [_      (debug "[<<<<<<Processing Arrivals!>>>>>>]")
             arr    (store/get-entity ctx :arrival) ;;known entity arrivals...
             {:keys [pending arrival-fn next-batch]}    arr
             new-entities (batch->entities pending)
             new-batch    (next-batch (:t pending) ctx)]
         (->> ctx
              (services/handle-arrivals (:t pending) new-entities)
              (services/schedule-arrivals new-batch)))
       (do (spork.ai.core/debug "No arrivals!")
           ctx)))
    ([ctx] (process-arrivals (or (store/gete ctx :parameters :batch->entities)
                                 services/batch->entities) ctx)))

(defprotocol IBatchProvider
  (peek-batch [o])
  (pop-batch  [o]))

;;do we compute the arrival time first?
;;If we have identical arrival times (dt = 0),
;;we need to consolidate the batches....
;;implication of multiple dt=0, is that
;;batches are arriving concurrently.
;;When we hit a dt <> 0, then we have future
;;batch...
(defn ->random-batch
  ([f size-f]
   (-> (loop [dt  (f)
              acc (size-f)]
         (if (pos? dt)
           {:n acc :dt dt}
           (recur (f) (+ acc (size-f)))))))
  ([f]   (-> (loop [dt  (f)
                    acc 1]
               (if (pos? dt)
                 {:n acc :dt dt}
                 (recur (f) (inc acc)))))))
;;given a start-time, and an extant delay, dt,
;;associates the start-time with t in the map.
(defn offset [t {:keys [dt] :as b}]
  (assoc b :t (+ dt t )))

(defn variable [n]
  (cond (fn? n) n
        (number? n) (fn [] n)
        :else (ex-info "requires fn or numeric constant!" {})))

(defn next-batch
  "Given a start time t, and an interarrival time
   function f::nil->number, generates a map of
   {:n arrival-count :t next-arrival-time} where t
   is computed by sampling from f, such that the
   interarrival time is non-zero.  Zero-values
   are aggregated into the batch via incrementing
   n, accounting for concurrent arrivals (i.e. batches)."
  ([t interarrival]
   (->> (->random-batch (variable interarrival))
        (offset t )))
  ;;complecting...I think batch->entities should handle behavior...
  ([t f b] (assoc (next-batch t f) :behavior b))
  ([t interarrival size b]
   (as-> (->random-batch (variable interarrival) (variable size)) it
         (offset t it)
         (assoc it :behavior b))))

;;this works for persistent, immutable batches.
(defn gen-batch
  ([t {:keys [tstart tstop interarrival size capacity behavior]}]
   (when (and  (>= t tstart)
               (or (not tstop) (< t tstop)))
     (let [b (next-batch t interarrival size behavior)]
       (if-not capacity b
               (let [n (:n b)
                     delta (- capacity n)]
                 (if (pos? delta)
                   b
                   (assoc b :n capacity)))))))
  ([b] (gen-batch 0 b)))


;;currently, random batches are maps.
;;constant batches are sequences of primitive entities.
(defn peek-batch-map [m]
  (:pending m))

(defn in-bounds? [m b]
  (or (not (:tstop m))
      (<= (:t b) (:tstop m))))

;;maybe move to batchseed impl
(defn push-batch-map [m b]
  (let [newm (assoc m :pending b)]
    (if-not (:capacity m)
      newm
      (update newm :capacity - (:n b)))))

;;maybe move to batchseed impl
(defn pop-batch-map [m]
  (let [b          (peek-batch m) 
        new-batch  (gen-batch (:t b) m)]
   (if (in-bounds? m new-batch)
     (push-batch-map m new-batch)
     (assoc m :pending nil))))


;;We can compute a successive batch from a seed
(defrecord batchseed [tstart tstop interarrival size  capacity behavior]
  IBatchProvider
  (peek-batch [o] (peek-batch-map o))
  (pop-batch  [o] (pop-batch-map o)))

(defn ->random-schedule
  [& {:keys [tstart tstop interarrival size  capacity behavior]
      :or {tstart 0 size 1}}]
  (let [b (->batchseed tstart
                       tstop
                       interarrival
                       size
                       capacity
                       behavior)
        pending (gen-batch tstart b)]
    {:pending       (assoc b :pending pending)
     :t             (:t pending)
     :schedule-type :random}))

;;defines a sequence-based schedule of entity arrivals
;;no batch-see defined.
(defn ->known-schedule [behavior xs]
  {:pending  xs
   :t        (:t (first xs))
   :behavior behavior
   :schedule-type :known})

(defn generic-peek [o]
  (case (:schedule-type o)
    :random (peek-batch (:pending o))
    :known  (first (:pending o))
    (throw (ex-info "unknown-schedule-type" o))))
    
;;this is just a simple wrapper around generic maps
;;and entities
;;to implement arrivals schedules.
(defn generic-pop  [o]
  (case (:schedule-type o)
    :random  (as-> o it
               (update it :pending pop-batch)
               (if-let [t (:t (peek-batch it))]
                 (assoc it :t t)
                 (dissoc it :t)))
    :known   (as-> o it
               (update it :pending (comp seq rest))
               (if-let [t (:t (peek-batch it))]
                 (assoc it :t t)
                 (dissoc it :t)))
    (throw (ex-info "unknown-schedule-type" o))))

(extend-protocol IBatchProvider
  clojure.lang.PersistentArrayMap
  (peek-batch [o] (generic-peek o))
  (pop-batch  [o] (generic-pop o))
  clojure.lang.PersistentArrayMap
  (peek-batch [o] (generic-peek o))
  (pop-batch  [o] (generic-pop o))
  spork.entitysystem.store.entity
  (peek-batch [o] (generic-peek o))
  (pop-batch  [o] (generic-pop o)))

(defn peek-pop-batch [sched]
  [(peek-batch sched) (pop-batch sched)])

;;useful for testing...
(defn finite-schedule [bt]
  (->> bt
       (iterate pop-batch)
       (take-while :pending)
       (map :pending)))

;;in services..
;;If we have active-schedules, they have batches.
;;we need to pop the next batch from the each schedule.
;;This will produce a new schedule, and in turn,
;;request.  compute the entity batches, new updates, and updated
;;schedules.
(defn pop-batches
  "Given a context, and entity realization function, and selected schedule
  entities, computes a map of {:keys [entities updates schedules]}"
  ([batch->entities schedules]
  ;;we need to traverse each schedule
   (reduce (fn [{:keys [entities updates schedules ctx]} sched]
             (let [b                (peek-batch sched) ;;get the next-batch.
                   new-sched        (pop-batch  sched)] ;;get the next-schedule (if any)
               {:entities  (into entities (batch->entities b)) ;;collect entities
                :updates   (if-let [t (:t (peek-batch new-sched))]
                             (conj updates t) updates)
                :schedules (conj schedules new-sched)}))
           {:entities  [] :updates   #{} :schedules []} schedules))
  ([schedules] (pop-batches (fn [b]
                              (or (:entities b)
                                  (throw (ex-info "default batch fn only works on known entities!" b))))
                            schedules)))
                                

(defn random-ents [n]
  (for [n (range n)]
    {:t n
     :entities (services/batch->entities {:t n :n 1 :behavior nil})}))

;;in services...
(defn active-schedules
  ([ctx t schedule-names]
     (store/select-entities ctx
                            :from [:schedule-type]
                            :where (fn [e] (= (:t e) t))))
  ([ctx t] (when-let [names (store/gete ctx :arrival :schedules)]
             (active-schedules ctx t names)))
  ([ctx] (when-let [names (store/gete ctx :arrival :schedules)]
           (active-schedules ctx (spork.sim.core/get-time ctx)
                             names))))

(defn get-schedules [ctx]
  (-> ctx 
      (store/select-entities :from [:schedule-type])))

;;High Level API
;;==============

;;We have the concept of schedules, which imply entity arrivals...
(defn next-schedule-id [ctx]
  (keyword (str "schedule" (or (some-> (store/get-domain ctx :schedule-type) count)
                               0))))

;;how do we define schedules?
;;Is there a default schedule we can use?
;;If we don't define a name for the schedule, we
;;just push onto the :default schedule?
;;or do we generate a name for it?
(defn push-schedule
  ([ctx id sched]
   ;;we add the schedule entity, and ensure it's
   ;;registered with the arrival entity.
   (let [arr     (store/get-entity ctx :arrival)
         t       (:t (peek-batch sched))]
     (-> ctx 
         (store/add-entity (merge arr
                                  {:schedules (-> arr
                                                  (get :schedules #{})
                                                  (conj id))
                                   :tnext     (if-let [tprev (:tnext arr)]
                                                (min tprev t)
                                                t)}))
         (store/add-entity (assoc sched :name id)))))
  ([ctx sched]
   ;;create a new schedule id and push sched
   (push-schedule ctx (next-schedule-id ctx) sched)))

(comment ;;testing
  (def known-schedule  (->known-schedule  :default-behavior (random-ents 3)))
  (def random-schedule (->random-schedule :tstart 10 :tstop 50
                                          :interarrival #(rand-int 5)
                                          :size 1 :behavior :default-behavior))
  (def ctx (-> spork.sim.core/emptysim
               (store/add-entity {:name :arrival})
               (push-schedule  known-schedule)
               (push-schedule  random-schedule)))
  
)

(comment

  ;;we want to alter services/schedule-arrivals to use
  ;;some variant of push-schedule....
  
(defn init
  "Creates an initial context with a fresh distribution, schedules initial
   batch of arrivals too.  If no inital arrivals are provided,
   generates an initial arrival batch based on the supplied
   distribution."
  ([ctx & {:keys [default-behavior service-network initial-arrivals
                  interarrival batch-size]
           :or {default-behavior beh/client-beh
                service-network  services/basic-network
                interarrival (stats/exponential-dist 5) 
                batch-size 1}}]
   (let [next-arrival (fn next-arrival [] (long (interarrival)))
         next-size    (if (number? batch-size)
                        (let [n (long batch-size)] (fn next-size [] n))
                        (fn next-size    [] (long (batch-size))))
         ;;default batching function assumes current-time and builds
         ;;a batch stochastically based on random interarrival time
         ;;and random batch-size (if specified).
         ;;next-batch should take 2 arity, t and ctx, to allow
         ;;other batch functions to access the context, say to
         ;;compute deferred batches (pre-scheduled arrivals).
         next-batch   (fn next-batch   [t ctx]
                          (services/next-batch t
                              next-arrival next-size default-behavior))]
     (->>  ctx 
           (sim/merge-entity  {:arrival {:arrival-fn next-arrival
                                         :batch-size next-size
                                         :next-batch next-batch}
                               :parameters {:default-behavior default-behavior
                                            :service-network  service-network}})
           (services/schedule-arrivals
            (or initial-arrivals
                (next-batch (sim/get-time ctx) ctx))
              #_(services/next-batch (sim/get-time ctx) f default-behavior))
           (services/register-providers service-network)
           )))
  ([] (init emptysim)))
  
  (defn init-arrivals [ctx xs]
    )
  )


(comment 


;;new....
(defn process-arrivals
  "The arrivals system processes batches of entities and schedules more arrival
   updates.  batch->entities should be a function that maps a batch, 
   {:t long :n long} -> [entity*]"
  ([batch->entities ctx]
   (if-let [arrivals? (seq (sim/get-updates :arrival (sim/current-time ctx) ctx))]
     (let [_      (debug "[<<<<<<Processing Arrivals!>>>>>>]")
           ;;look up the schedules in arrivals for entities.
           schedules (services/active-schedules ctx
                        (sim/current-time ctx)
                        (store/gete ctx :arrival :schedules))
           ;;compute the entity batches, new updates, and updated schedules.
           {:keys [entities updates schedules]}
               (services/pop-batches ctx batch->entities schedules)]
       (as-> newctx ctx
         (request-updates :arrival updates newctx) ;merge arrival  updates.
         (merge-entities newctx schedules)         ;merge new schedules.
         ;;process the entities from the batches in the new context.
         (services/handle-arrivals newctx t new-entities entities)))
     (do (spork.ai.core/debug "No arrivals!")
         ctx)))
  ([ctx] (process-arrivals (or (store/gete ctx :parameters :batch->entities)
                               services/batch->entities) ctx)))
)


















